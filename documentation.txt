MERN From Scratch 2023 | eCommerce Platform


Section 1: Introduction

1. Welcome To The Course

2. Course Project Intro

3. Course Code Repo

4. Getting Started


Section 2: Starting The Front End

5. React Setup & Git Initialize
-kreiramo folder frontend
-instaliramo Vite React projekt

6. Header & Footer Components
-u terminalu instalirano React Bootstrap i React ikonice paket
-u main.jsx komponentu importujemo React Bootstrap css fajl
-u folderu src kreiramo folder components
-u folderu components kreiramo komponentu Header.jsx
-u komponentu Header.jsx importujemo React Bootstrap komponente i React ikonice
-u komponentu App.jsx importujemo komponentu Header.jsx i React Bootstrap komponente
-u folderu components kreiramo komponentu Footer.jsx
-u komponentu Footer.jsx importujemo React Bootstrap komponente
-u komponentu App.jsx importujemo komponentu Footer.jsx

7. Custom Bootstrap Theme
-u folderu assets kreiramo folder styles
-u folderu styles kreiramo bootstrap.custom.css i index.css fajlove
-u folder assets dodajemo sliku
-u komponentu Header.jsx importujemo sliku logo

8. List Products
-u folderu public kreiramo folder images sa slikama
-u folderu src kreiramo product.js fajl
-kreiramo folder screens
-u folderu screens kreiramo komponentu HomeScreen.jsx
-u komponentu HomeScreen.jsx importujemo React Bootstrap komponente
-importujemo products fajl
-u return izjavi varijabli products dodajemo metodu map()
-u komponentu App.jsx importujemo komponentu HomeScreen.jsx
-u folderu components kreiramo komponentu Product.jsx
-u komponentu HomeScreen.jsx importujemo komponentu Product.jsx

9. Implement React Router
-u terminalu instaliramo paket React Router Dom
-u main.jsx komponentu importujemo funkcije iz React Router Dom paketa
-kreiramo funkciju createBrowserRouter()
-u funkciju createBrowserRouter() proslijedujemo funkciju createRoutesFromElements()
-u funkciji createRoutesFromElements kreiramo komponentu Route
-vrijednost funkcije createBrowserRouter() pohranjujemo u varijablu const router
-u metodu render() dodajemo komponentu RouterProvider
-komponenti RouterProvider dodajemo prop router
-u prop router proslijedujemo varijablu router
-u komponentu App.jsx importujemo komponentu Outlet iz React Router Dom paketa
-u terminalu instaliramo paket React Router Bootstrap
-u komponentu Header importujemo komponentu LinkContainer

10. Rating Component
-kreiramo komponentu Rating.jsx
-u komponentu Rating.jsx importujemo React ikonice
-funkciji Rating dodajemo parametre destruktuirane prop
-u komponentu Product.jsx importujemo komponentu Rating.jsx

11. Product Details Page
-u folderu screens kreiramo komponentu ProductScreen.jsx
-u komponentu ProductScreen.jsx importujemo React Hook useParams
-importujemo fajl products
-destruktuiramo id iz funkcije React Hook useParams()
-kreiramo varijablu const product


Section 3: Serving & Fetching Data

12. Full Stack Workflow & Explanation

13. Express Server & Initial Product Routes
-kreiramo .gitignore fajl 
-kreiramo folderu backend
-u terminalu udemo u folder backend sa komandom cd backend
-u terminalu ukucamo komandu npm init da inicijaliziramo package.json fajl
-kreiramo server.js fajl
-u server.js fajlu kreiramo express setup

14. Nodemon & Concurrently
-u terminalu instaliramo Nodemon paket
-backend pokrenemo sa komandom npm run server

15. Environment Variables
-u terminalu instaliramo paket Dotenv
-u server.js fajl importujemo dotenv paket

16. Fetch Products
-u folderu frontend instaliramo paket Axios
-u komponentu HomeScreen.jsx importujemo useState i useEffect React Hooks
-kreiramo state varijablu products i funkciju setProducts
-kreiramo funkciju useEffect()
-u funkciji useEffect() kreiramo asinhronu funkciju fetchProducts
-u komponentu ProductScreen.jsx importujemo useState i useEffect React Hooks
-kreiramo funkciju useEffect()
-kreiramo state varijablu product i funkciju setProduct
-u funkciji useEffect() kreiramo asinhronu funkciju fetchProduct


Section 4: Starting MongoDB & Mongoose

17. MongoDB Atlas Setup
-kreiramo Cloud bazu podataka MongoDB Atlas

18. MongoDB Compass Setup
-preuzmemo Desktop verziju aplikacije

19. Connect With Mongoose
-u folderu backend, u terminalu instaliramo paket Mongoose
-kreiramo folder config
-u folderu config kreiramo db.js fajl
-u db.js fajl importujemo objekt mongoose
-kreiramo asinhronu funkciju connectDB()
-u asinhronoj funkciji connectDB() kreiramo blokove koda try - catch
-u server.js fajl importujemo funkciju connectDB
-pozivamo funkciju connectDB()

20.  Modeling Our Data
-u folderu backend, kreiramo folder models
-u folderu models kreiramo productModel.js fajl
-u productModel.js fajl importujemo objekt mongoose
-kreiramo funkciju mongoose.Schema({ ... })
-vrijednost mongoose.Schema({ ... }) pohranjujemo u varijablu const productSchema
-kreiramo i eksportujemo varijablu const Product kao default
-kreiramo varijablu reviewSchema
-kreiramo userModel.js fajl
-kreiramo varijablu const userSchema 
-kreiramo varijablu const User
-kreiramo orderModel.js fajl
-kreiramo varijablu orderSchema
-kreiramo i eksportujemo varijablu const Order kao default

21. Prepare Sample Data
-u folderu data kreiramo users.js fajl
-u terminalu instaliramo bcrypt paket
-u users.js fajlu kreiramo varijablu const users 

22. Seeding Sample Data
-u folderu backend kreiramo seeder.js fajl
-u seeder.js fajlu kreiramo asinhronu funkciju importData()
-kreiramo asinhronu funkciju destroyData()
-u package.json fajlu dodajemo komande za seeder.js fajl

23. Getting Started With Postman
-kreiramo i testiramo rute u Postman-u

24. Get Products from Database
-u folderu backend kreiramo folder routes
-u folderu routes kreiramo productRoutes.js fajl
-u server.js fajl importujemo varijablu productRoutes
-kreiramo metodu app.use('/api/products', productRoutes)
-u folderu backend kreiramo folder middleware
-u folderu middleware kreiramo asyncHandler.js fajl
-u asyncHandler.js fajlu kreiramo funkciju asyncHandler()
-u productRoutes.js fajl importujemo funkciju asyncHandler
-importujemo objekt Product
-u metodi router.get('/') kreiramo varijablu const products
-kreiramo metodu res.json(products)
-u metodi router.get('/:id') kreiramo varijablu const product
-dodajemo uslov if (product)
-kreiramo metodu res.status(404).json({ ... })

25. Custom Error Middleware
-u folderu middleware kreiramo errorMiddleware.js fajl
-u errorMiddleware.js fajlu kreiramo i eksportujemo funkcije notFound() i errorHandler()
-u server.js fajl importujemo kreirane funkcije 
-kreiramo dvije metode app.use(notFound) i app.use(errorHandler)

26. Product Controller
-kreiramo folder controllers
-u folderu controllers kreiramo productController.js fajl
-u productController.js fajlu kreiramo funkcije getProducts() i getProductById()
-u productRoutes.js fajlu kreiramo dvije metode router.route()


Section 5: Redux Toolkit Setup & State Management

27. Redux & State Overview

28. Redux Store & API Slice
-u folderu frontend, u terminalu instaliramo React Redux i Redux Toolkit pakete
-u folderu src kreiramo store.js fajl
-u store.js fajl importujemo funkciju configureStore
-kreiramo funkciju configureStore({ ... })
-vrijednost funkcije configureStore() pohranjujemo u varijablu const store
-u main.jsx komponentu importujemo komponentu Provider
-importujemo varijablu store
-komponenti Provider dodajemo prop store
-u prop store proslijedujemo varijablu store
-kreiramo constants.js fajl
-u constants.js fajlu kreiramo i eksportujemo varijable
-u folderu src kreiramo folder slices
-u folderu slices kreiramo apiSlice.js fajl
-u apiSlice.js fajl importujemo funkcije createApi i fetchBaseQuery
-importujemo varijablu BASE_URL
-kreiramo varijablu const baseQuery
-kreiramo funkciju createApi({ ... })
-vrijednost funkcije createApi() pohranjujemo u varijablu const apiSlice
-u store.js fajl importujemo varijablu apiSlice

29. Products API Slice & Get Products Endpoint
-u folderu slices kreiramo productsApiSlice.js fajl
-u productsApiSlice.js fajl importujemo funkciju apiSlice i varijablu PRODUCTS_URL
-kreiramo funkciju apiSlice.injectEndpoints({ ... })
-vrijednost funkcije apiSlice.index() pohranjujemo u varijablu const productsApiSlice
-eksportujemo funkciju useGetProductsQuery
-u komponentu HomeScreen.jsx importujemo funkciju useGetProductsQuery 

30. Get Product Details Endpoint Challenge
-u productsApiSlice.js fajlu kreiramo endpoint funkciju getProductDetails i eksportujemo funkciju useGetProductDetailsQuery
-u komponentu HomeScreen.jsx importujemo funkciju useGetProductDetailsQuery

31. Loader & Message Components
-u folderu components kreiramo komponentu Loader.jsx 
-u komponente HomeScreen.jsx i ProductScreen.jsx importujemo komponentu Loader.jsx
-u folderu components kreiramo komponentu Message.jsx
-u komponentu Message.jsx importujemo komponentu Alert iz React Bootstrap paketa
-u komponente HomeScreen.jsx i ProductScreen.jsx importujemo komponentu Message.jsx


Section 6: Shopping Cart Functionality

32. Cart Slice & Reducer
-u folderu slices kreiramo cartSlice.js fajl
-u cartSlice.js fajl importujemo funkciju createSlice
-kreiramo varijablu const initialState
-kreiramo funkciju createSlice({ ... })
-vrijednost funkcije createSlice() pohranjujemo u varijablu const cartSlice

33. Add To Cart Function
-u cartSlice.js fajlu, u objektu reducers kreiramo funkciju addToCart
-kreiramo funkciju addDecimals()
-eksportujemo funkciju addToCart kao cartSlice.actions

34. Qty & Add To Cart Handler
-u komponentu ProductScreen.jsx importujemo React Hook useState
-kreiramo state varijablu const [qty, setQty] = useState(1)
-importujemo komponentu Form iz paketa React Bootstrap
-kreiramo uslov product.countInStock > 0 && () 
-kreiramo funkciju addToCartHandler()
-komponenti Button dodajemo prop onClick
-u prop onClick proslijedujemo funkciju addToCartHandler
-importujemo funkciju addToCart iz cartSlice.js fajla
-importujemo useNavigate React Hook iz paketa React Router Dom
-importujemo funkciju useDispatch iz paketa React Redux
-kreiramo funkciju useDispatch()
-vrijednost funkcije useDispatch() pohranjujemo u varijablu const dispatch
-kreiramo funkciju useNavigate()
-vrijednost funkcije useNavigate() pohranjujemo u varijablu const navigate
-u funkciju addToCartHandler() dodajemo funkciju dispatch(addToCart({ ... }))

35. Cart Utils File
-u folderu src kreiramo folder utils
-u folderu utils kreiramo cartUtils.js fajl
-u cartSlice.js fajlu kreiramo dvije funkcije addDecimals() i updateCart()

36. Item Count in Header
-u komponentu Header.jsx importujemo React Hook useSelector
-kreiramo funkciju useSelector()
-iz funkcije useSelector() destruktuiramo varijablu cartItems
-importujemo komponentu Badge
-u return izjavu, dodajemo uslov cartItems.length > 0 && (...)

37. Cart Screen
-kreiramo komponentu CartScreen.jsx
-u komponenti CartScreen.jsx kreiramo varijable navigate, dispatch
-kreiramo varijablu const cart
-destruktuiramo varijablu cartItems iz varijable cart
-u return izjavu dodajemo uslov cartItems.length === 0
-u komponentu ListGroup dodajemo metodu cartItems.map()
-u komponenti Form.Control dodajemo metodu [...Array(item.countInStock).keys()]
-kreiramo funkciju addToCartHandler()
-importujemo funkciju addToCart
-komponenti FormControl dodajemo prop onChange
-u prop onChange proslijedujemo funkciju addToCartHandler
-u funkciju addToCartHandler() dodajemo funkciju dispatch(addToCart({ ... }))

38. Remove From Cart
-u cartSlice.js fajlu kreiramo funkciju removeFromCart
-u komponentu CartScreen.jsx importujemo funkciju removeFromCart
-kreiramo funkciju removeFromCartHandler()
-u funkciju removeFromCartHandler() dodajemo funkciju dispatch(removeFromCart())
-kreiramo funkciju checkoutHanlder
-komponenti Button Proceed To Checkout dodajemo prop onClick
-u prop onClick proslijedujemo funkciju checkoutHanlder


Section 7: Backend Authentication

39. User Routes & Controller
-u folderu backend kreiramo fajlove userController.js i userRoutes.js
-u userController.js fajlu kreiramo i eksportujemo funkcije authUser(), registerUser(), logoutUser(), getUserProfile(), updateUserProfile(), getUsers(), getUserById(), deleteUser(), updateUser()
-importujemo User Model
-u userRoutes.js fajl importujemo funkcije iz userController.js fajla
-kreiramo rute za importovane funkcije
-kreiramo i eksportujemo varijablu const router kao default
-u server.js fajl importujemo router iz userRoutes.js fajla kao userRoutes
-kreiramo metodu app.use('/api/users', userRoutes)
-kreiramo i testiramo rute u Postman-u

40. User Email & Password Validation
-u server.js fajlu kreiramo metodu app.use(express.json())
-kreiramo metodu app.use(express.urlencoded({ extended: true }))
-u userController.js fajlu u funkciji authUser() kreiramo metodu await User.findOne({ email })
-vrijednost metode User.findOne() pohranjujemo u varijablu const user
-u userModel.js fajl importujemo paket Bcrypt
-kreiramo metodu userSchema.methods.matchPassword
-u userController.js fajlu, u funkciju authUser() dodajemo uslov if (user && (await user.matchPassword(password)))
-dodajemo uslov else
-u uslov else dodajemo metodu res.status(401)
-dodajemo objekt throw new Error()

41. How Do JSON Web Tokens Work ?

42. JWT HTTP Only Cookie
-u folderu backend instaliramo paket Jsonwebtoken sa komandom npm i jsonwebtoken
-u userController.js fajlu, u funkciji authUser() kreiramo varijablu const token
-importujemo varijablu jwt iz paketa Jsonwebtoken
-kreiramo metodu res.cookie()
-u .env fajlu kreiramo varijablu JWT_SECRET

43. Auth Middleware & Endpoint
-u terminalu instaliramo paket Cookie Parser sa komandom npm i cookie-parser
-u server.js fajl importujemo varijablu cookieParser
-kreiramo metodu app.use(cookieParser())
-u folderu middleware kreiramo authMiddleware.js fajl
-importujemo varijablu jwt
-importujemo funkciju asyncHandler
-importujemo objekt User
-kreiramo i eksportujemo funkciju protect()
-u funkciji protect kreiramo varijablu let token
-inicijaliziramo varijablu token = req.cookies.jwt
-dodajemo uslov if (token)
-dodajemo uslov else
-u blok koda else dodajemo metodu res.status(401) i objekt Error
-u uslov if (token) dodajemo blokove koda try - catch
-u bloku koda try kreiramo varijablu const decoded
-dodajemo metodu await User.findById()
-dodajemo funkciju next()
-kreiramo i eksportujemo funkciju admin() sa tri parametre req, res, next
-u funkciju admin() dodajemo uslov if (req.user && req.user.isAdmin)
-dodajemo uslov else
-u uslov else dodajemo res.status(401) i objekt Error
-u userRoutes.js fajl importData funkcije protect i admin
-testiramo rute u Postman-u

44. Logout User & Clear Cookie
-u userController.js fajlu, u funkciji logoutUser() kreiramo metodu res.cookie()
-dodajemo metodu res.status(200).json({ ... })
-testiramo rute u Postman-u

45. User Register Endpoint & Encryption
-u userController.js fajlu, u funkciji registerUser() destruktuiramo varijable const { name, email, password } = req.body
-kreiramo varijablu const userExists
-dodajemo uslov if (userExists)
-u uslov if (userExists) dodajemo metodu res.status(400) i objekt Error
-kreiramo metodu await User.create({ ... })
-vrijednost metode User.create() pohranjujemo u varijablu const user
-dodajemo uslov if (user)
-u uslov if (user) dodajemo metodu res.status(201).json({ ... })
-dodajemo uslov else
-u uslov else dodajemo metodu res.status(400) i objekt Error
-u userModel.js fajlu kreiramo metodu userSchema.pre('save', ...)
-u anonimnu funkciju sa parametrom next dodajemo uslov if (!this.isModified('password'))
-u uslov if dodajemo funkciju next()
-dodajemo metodu await bcrypt.genSalt(10)
-vrijednost metode await bcrypt pohranjujemo u varijablu const salt
-dodajemo metodu await bcrypt.hash(this.password, salt)
-vrijednost metode bcrypt.hash() pohranjujemo u varijablu this.password
-kreiramo folder utils
-u folderu utils kreiramo generateToken.js fajl
-u generateToken.js fajl importData varijablu jwt
-kreiramo funkciju generateToken() sa dva parametra res i userId
-u funkciji generateToken() kreiramo varijablu const token i metodu res.cookie()
-funkciju generateToken eksportujemo kao default
-u userController.js fajl importujemo funkciju generateToken()
-u funkciju authUser() dodajemo funkciju generateToken();
-u funkciju registerUser() dodajemo funkciju generateToken()

46. User Profile Endpoints
-u userController.js fajlu, u funkciji getUserById() kreiramo varijablu const user
-dodajemo uslov if (user)
-u uslov if (user) dodajemo metodu res.status(200).json({ ... })
-dodajemo uslov else
-u uslov else dodajemo metodu res.status(404) i objekt Error
-u funkciji updateUserProfile() kreiramo varijablu const user
-dodajemo uslov if (user)
-u uslov if (user) dodajemo uslov if (req.body.password)
-dodajemo metodu await user.save()
-vrijednost metode await user.save() pohranjujemo u varijablu const updatedUser
-dodajemo metodu res.status(200).json({ ... })
-za uslov koda if (user) dodajemo uslov else
-u uslov else dodajemo metode res.status(404) i objekt Error


Section 8: Frontend Authentication

47. Auth & User API Slice
-u folderu frontend, u folderu slices kreiramo authSlice.js fajl
-u authSlice.js fajl importujemo funkciju createSlice
-kreiramo varijablu const initialState
-kreiramo funkciju createSlice({ ... })
-vrijednost funkcije createSlice() pohranjujemo u varijablu const authSlice
-eksportujemo varijablu setCredentials kao authSlice.actions
-eksportujemo varijablu authSlice.reducer kao default
-u store.js fajl importujemo varijablu authSliceReducer
-u objekt reducer dodajemo auth: authSliceReducer
-u folderu slices kreiramo usersApiSlice.js fajl
-kreiramo i eksportujemo varijablu const usersApiSlice
-eksportujemo funkciju useLoginMutation

48. Login Screen
-u folderu components kreiramo komponentu FormContainer.jsx
-funkciji FormContainer() dodajemo parametar destruktuirani prop children
-importujemo React Bootstrap komponente Container, Row, Col
-u folderu screens kreiramo komponentu LoginScreen.jsx
-u komponentu LoginScreen.jsx importovane React Hook useState
-importujemo komponentu Link iz paketa React Router Dom
-importujemo komponente Form, Button, Row, Col iz paketa React Bootstrap
-importujemo komponentu FormContainer
-kreiramo state varijable email i password
-kreiramo funkciju submitHandler() sa parametrom e
-u return izjavu dodajemo komponentu FormContainer kao roditelj komponentu
-u komponentu FormContainer kreiramo komponentu Form
-komponenti Form dodajemo prop onSubmit
-u prop onSubmit proslijedujemo funkciju submitHandler
-u komponenti Form kreiramo komponente Form.Group i Form.Control
-ponovimo isti postupak za sifru
-kreiramo komponentu Button
-u komponentu main.jsx importujemo komponentu LoginScreen.jsx
-kreiramo komponentu Route za komponentu LoginScreen

49. Login Functionality
-u terminalu instaliramo paket React Toastify sa komandom npm i react-toastify
-u komponentu App.jsx importujemo komponentu ToastContainer iz paketa React Toastify
-u return izjavu dodajemo komponentu ToastContainer
-u komponentu LoginScreen.jsx importujemo React Hook useEffect
-importujemo funkcije useLocation i useNavigate iz paketa React Router Dom
-importujemo funkcije useDispatch i useSelector iz pakete React Redux
-importujemo komponentu Loader.jsx
-importujemo funkcije useLoginMutation i setCredentials
-importujemo objekt toast iz paketa React Toastify
-kreiramo varijable const dispatch i const navigate
-kreiramo varijable const [login, { isLoading }] = useLoginMutation()
-destruktuiramo varijablu const { userInfo } pomocu funkcije useSelector()
-destruktuiramo varijablu const { search } = useLocation()
-kreiramo varijablu const sp (search params)
-kreiramo varijablu const redirect
-kreiramo funkciju useEffect()
-u funkciji submitHandler() kreiramo try - catch blokove koda
-u bloku koda try kreiramo varijablu const res
-dodajemo funkciju dispatch(setCredentials({ ... res }))
-u blok koda catch(error) dodajemo objekt toast.error()
-u komponentu Form dodajemo uslov {isLoading && <Loader />}
-u komponenti Header.jsx destruktuiramo varijablu const { userInfo }
-u komponentu Header.jsx importujemo komponentu NavDropdown
-u return izjavu dodajemo uslov {userInfo ? () : ()}
-kreiramo funkciju logoutHandler()
-komponenti NavDropdown.Item dodajemo prop onClick
-u prop onClick proslijedujemo funkciju logoutHandler

50. User Logout
-u usersApiSlice.js fajlu kreiramo funkciju logout
-eksportujemo funkciju useLogoutMutation
-u authSlice.js fajlu kreiramo funkciju logout
-u komponentu Header.jsx importujemo funkciju useLogoutMutation
-importujemo funkcije logout, useNavigate, useDispatch
-kreiramo varijablu const dispatch i const navigate
-u funkciju logoutHandler() dodajemo blokove koda try - catch
-destruktuiramo varijablu const [logoutApiCall] = useLogoutMutation()
-u blok koda try dodajemo await logoutApiCall().unwrap()
-dodajemo funkciju dispatch(logout())
-dodajemo navigate('/login')

51. User Registration
-u usersApiSlice.js fajlu kreiramo funkciju register
-eksportujemo funkciju useRegisterMutation
-u folderu screens kreiramo komponentu RegisterScreen.jsx
-kopiramo kod iz LoginScreen.jsx komponente i napravimo manje izmjene
-kreiramo nove state varijable name i confirmPassword
-u funkciji submitHandler dodajemo uslov if (password !== confirmPassword)
-dodajemo uslov else
-u uslov else dodajemo blokove koda try - catch
-u komponentu main.jsx importujemo komponentu RegisterScreen.jsx


Section 9: Checkout Process - Part 1

52. Shipping Screen
-u folderu frontend, u cartSlice.js fajlu, dodajemo shippingAddress i paymentMethod
-kreiramo i eksportujemo funkciju saveShippingAddress()
-u folderu screens kreiramo komponentu ShippingScreen.jsx
-u komponentu ShippingScreen.jsx importujemo komponentu FormContainer
-importujemo komponente Form, Button iz paketa React Bootstrap
-kreiramo state varijable address, city, postalCode, country
-u komponentu main.jsx importujemo komponentu ShippingScreen.jsx
-kreiramo rutu '/shipping' za komponentu ShippingScreen
-u komponenti ShippingScreen.jsx kreiramo funkciju submitHandler()
-u return izjavi kreiramo komponentu FormContainer kao roditelj komponentu
-kreiramo komponentu Form
-komponenti Form dodajemo prop onSubmit
-u prop onSubmit proslijedujemo funkciju submitHandler
-kreiramo komponente Form.Group, Form.Label, Form.Control
-kreiramo komponentu Button
-importujemo funkcije useDispatch i useSelector iz paketa React Redux
-importujemo funkciju useNavigate iz paketa React Router Dom
-importujemo funkciju saveShippingAddress iz cartSlice.js fajla
-kreiramo funkciju useSelector()
-vrijednost funkcije useSelector() pohranjujemo u varijablu const cart
-destruktuiramo varijablu const { shippingAddress } = cart
-kreiramo varijable const navigate i const dispatch
-u funkciju submitHandler() dodajemo funkciju  dispatch(saveShippingAddress({ ... }))
-dodajemo varijablu navigate('/payment')

53. Private Routes
-u folderu components kreiramo komponentu PrivateRoute.jsx
-importujemo komponente Outlet i Navigate iz pakete React Router Dom
-importujemo funkciju useSelector iz paketa React Redux
-destruktuiramo varijablu const { userInfo }
-u return izjavu dodajemo uslov ternarni operator return userInfo
-u komponentu main.jsx importujemo komponentu PrivateRoute.jsx
-kreiramo rutu za komponentu PrivateRoute
-u rutu za komponentu PrivateRoute dodajemo rutu za komponentu ShippingScreen

54. Checkout Steps Component
-u folderu components kreiramo komponentu CheckoutSteps.jsx
-u komponente CheckoutSteps.jsx importujemo komponente Nav i LinkContainer
-funkciji CheckoutSteps() dodajemo parametre destruktuirane props step1, step2, step3, step4
-u return izjavi kreiramo komponentu Nav kao roditelj komponentu
-kreiramo komponentu Nav.Item
-u komponenti Nav.Item dodajemo ternarni uslov step1 ? () : ()
-u komponentu ShippingScreen.jsx importujemo komponentu CheckoutSteps.jsx
-u return izjavi komponenti CheckoutSteps dodajemo props
-u komponenti CheckoutSteps ponovo postupak za props step2, step3 i step4

55. Payment Method 
-u cartSlice.js fajlu kreiramo i eksportujemo funkciju savePaymentMethod()
-u folderu screens kreiramo komponentu PaymentScreen.jsx
-u komponentu PaymentScreen.jsx importujemo komponente Form, Button, Col iz paketa React Bootstrap
-importujemo React Hook useState i useEffect
-importujemo funkcije useDispatch i useSelector iz paketa React Redux
-importujemo funkciju useNavigate iz paketa React Router Dom
-importujemo funkciju savePaymentMethod iz cartSlice.js fajla
-kreiramo state varijablu paymentMethod i funkciju setPaymentMethod
-importujemo komponente FormContainer i CheckoutSteps
-u return izjavi kreiramo komponentu FormContainer kao roditelj komponentu
-u komponenti FormContainer kreiramo komponentu CheckoutSteps
-komponenti CheckoutSteps dodajemo props step1 step2 i step3
-kreiramo komponente Form.Group, Form.Label, Col, Form.Check
-komponenti Form.Check dodajemo vise props
-u prop onChange proslijedujemo funkciju setPaymentMethod
-kreiramo komponentu Button
-u komponentu main.jsx importujemo komponentu PaymentScreen.jsx
-u zasticenoj ruti PrivateRoute kreiramo rutu '/payment' za komponentu PaymentScreen
-kreiramo varijable const dispatch i const navigate
-kreiramo funkciju useSelector()
-vrijednost funkcije useSelector() pohranjujemo u varijablu const cart
-destruktuiramo varijablu const {shippingAddress} = cart
-kreiramo funkciju useEffect()
-u funkciji useEffect(), u callback funkciju dodajemo uslov if(!shippingAddress)
-u uslov if dodajemo navigate('/shipping')
-kreiramo funkciju submitHandler
-komponenti Form dodajemo prop onSubmit
-u prop onSubmit proslijedujemo funkciju submitHandler
-u funkciju submitHandler() dodajemo funkciju dispatch()
-dodajemo varijablu navigate('/placeorder')

56. Order Routes & Controller
-u folderu backend, u folderu routes kreiramo orderRoutes.js fajl
-u folderu controllers kreiramo orderController.js fajl
-u orderController.js fajlu kreiramo funkcije addOrderItems, getMyOrders, getOrderById, updateOrderToPaid, updateOrderToDelivered, getOrders 
-eksportujemo funkcije
-u orderRoutes.js fajl importujemo funkcije iz orderController.js fajla
-u orderRoutes.js fajlu kreiramo rute
-eksportujemo varijablu router kao default
-u server.js fajl import varijablu orderRoutes
-kreiramo metodu app.use('/api/orders', orderRoutes)
-kreiramo i testiramo rute u Postman-u

57. Create & Get Orders
-u orderController.js fajlu,u funkciji addOrderItems destruktuiramo varijable iz req.body
-dodajemo uslov if (orderItems && orderItems.length === 0)
-u uslov if dodajemo metodu res.status(400)
-dodajemo objekt new Error()
-dodajemo uslov else
-u uslovu else kreiramo varijablu const order
-kreiramo varijablu const createdOrder
-dodajemo metodu res.status(201).json(createdOrder)
-u funkciji getMyOrders() kreiramo varijablu const orders
-dodajemo metodu res.status(200).json(orders)
-u funkciji getOrderById() kreiramo varijablu const order
-dodajemo uslov if (order)
-u uslov if dodajemo metodu res.status(200).json(order)
-dodajemo uslov else
-u uslov else dodajemo metodu res.status(404)
-dodajemo objekt Error()

58. Order API Slice & Start Order Screen
-u folderu frontend, u folderu slices kreiramo ordersApiSlice.js
-u ordersApiSlice.js fajlu kreiramo i eksportujemo varijablu const ordersApiSlice
-eksportujemo funkciju useCreateOrderMutation
-u cartSlice.js fajlu kreiramo i eksportujemo funkciju clearCartItems
-u folderu screens kreiramo komponentu PlaceOrderScreen.jsx
-u komponentu main.jsx importujemo komponentu PlaceOrderScreen.jsx
-u zasticenoj ruti PrivateRoute kreiramo rutu za '/placeholder' i komponentu PlaceOrderScreen
-u komponentu PlaceOrderScreen.jsx importujemo React Hook useEffect
-importujemo komponentu Link i funkciju useNavigate iz paketa React Router Dom
-importujemo komponente Button, Row, Col, ListGroup, Image, Card iz paketa React Bootstrap
-importujemo funkcije useSelector i useDispatch iz paketa React Redux
-importujemo komponentu CheckoutSteps
-kreiramo varijable const navigate i const dispatch
-kreiramo funkciju useSelector
-vrijednost funkcije useSelector pohranjujemo u varijablu const cart
-kreiramo funkciju useEffect()
-u funkcije useEffect, u callback funkciji dodajemo uslov if - else if
-u return izjavu kreiramo komponentu CheckoutSteps sa props
-kreiramo komponentu Row i komponente Col

59. Creating an Order
-importujemo objekt toast iz pakete React Toastify
-importujemo komponente Message.jsx i Loader.jsx
-importujemo funkciju useCreateOrderMutation iz ordersApiSlice.js fajla
-importujemo funkciju clearCartItems iz cartSlice.js fajla
-kreiramo komponente ListGroup, ListGroup.Item, Row, Col
-u komponentu ListGroup.Item dodajemo ternarni uslov cart.cartItems.length === 0 ? (...) : (...)
-kreiramo funkciju placeOrderHandler()
-kreiramo komponentu Button
-komponenti Button dodajemo prop onClick
-u prop onClick proslijedujemo funkciju placeOrderHandler
-kreiramo funkciju useCreateOrderMutation()
-vrijednost funkcije useCreateOrderMutation() pohranjujemo u varijable const [createOrder, { isLoading, error }]
-u komponentu ListGroup.Item dodajemo uslov  {error && <Message />}
-ispod komponente Button dodajemo uslov {isLoading && <Loader />}
-u funkciju placeOrderHandler() dodajemo blokove koda try - catch
-u bloku koda try kreiramo varijablu const res
-dodajemo funkciju dispatch(clearCartItems())
-u blok koda try dodajemo toast.error(error)


Section 10: Checkout Process - Part 2

60. Order Page
-u folderu frontend, u ordersApiSlice.js fajlu kreiramo funkciju getOrderDetails
-eksportujemo funkciju useGetOrderDetailsQuery 
-u folderu screens kreiramo komponentu OrderScreen.jsx 
-u komponentu OrderScreen.jsx importujemo komponentu Link i funkciju useParams iz paketa React Router Dom
-importujemo komponente iz paketa React Bootstrap
-importujemo funkciju useGetOrderDetailsQuery
-u komponentu main.jsx importujemo komponentu OrderScreen.jsx
-u zasticenu rutu PrivateRoute kreiramo rutu '/order/:id' za komponentu OrderScreen
-u OrderScreen.jsx komponenti kreiramo funkciju useGetOrderDetailsQuery(orderId)
-destruktuiramo varijable const { data:order, isLoading, error }
-u return izjavi dodajemo ternarni uslov za varijablu isLoading 
-kreiramo React Bootstrap komponente
-dodajemo ternarni uslov order?.isDelivered
-dodajemo ternarni uslov order?.isPaid
-dodajemo metodu order?.orderItems?.map()

61. PayPal Setup & Order Paid
-u folderu backend, u orderController.js fajlu, u funkciji updateOrderToPaid() kreiramo varijablu onst order 
-dodajemo uslov if (order)
-kreiramo varijablu const updatedOrder
-dodajemo metodu res.status(200).json(updatedOrder)
-dodajemo uslov else
-u uslov else dodajemo metodu res.status(404)
-dodajemo objekt Error()
-otvorimo web stranicu https://developer.paypal.com/home
-kreiramo PayPal racun
-u .env fajlu kreiramo varijable PAYPLAY_CLIENT_ID
-u server.js fajlu kreiramo metodu za PayPal app.get('/api/config/paypal')
-kreiramo varijablu const PAYPAL_CLIENT_ID

62. React - PayPal Integration
-otvorimo link https://www.npmjs.com/package/@paypal/react-paypal-js
-u folderu frontend instaliramo paket React Paypal u terminalu sa komandom npm i @paypal/react-paypal-js
-u komponentu main.jsx importujemo komponentu PayPalScriptProvider iz paketa React Paypal
-u metodi render() kreiramo komponentu PayPalScriptProvider sa otvorenim u zatvorenim tagom
-komponenti PayPalScriptProvider dodajemo prop deferLoading
-u komponentu PayPalScriptProvider dodajemo komponentu RouterProvider
-u ordersApiSlice.js fajlu kreiramo funkciju payOrder
-importujemo varijablu PAYPAL_URL 
-kreiramo funkciju getPayPalClientId
-eksportujemo funkcije usePayOrderMutation i useGetPayPalClientIdQuery
-u komponentu OrderScreen.jsx importujemo komponentu PayPalButtons i funkciju usePayPalScriptReducer iz paketa React PayPal
-importujemo funkcije usePayOrderMutation, useGetPayPalClientIdQuery iz ordersApiSlice.js fajl
-importujemo objekt toast iz paketa React Toastify
-importujemo funkciju useSelector iz paketa React Redux
-importujemo React Hook useEffect
-kreiramo funkciju usePayOrderMutation()
-destruktuiramo varijable const [payOrder, { isLoading: loadingPay }]
-kreiramo funkciju usePayPalScriptReducer()
-destruktuiramo varijable const [{ isPending }, paypalDispatch ]
-kreiramo funkciju useSelector()
-destruktuiramo varijablu const { userInfo }
-kreiramo funkciju useGetPayPalClientIdQuery()
-destruktuiramo varijable const { data: paypal, isLoading: loadingPayPal, error: errorPaypal }
-kreiramo funkciju useEffect()
-u funkciju useEffect(), u callback funkciju dodajemo uslov if (!errorPaypal && !loadingPayPal && paypal.clientId) 
-u uslovu if kreiramo asinhronu funkciju loadPayPalScript()
-u funkciju loadPayPalScript() dodajemo funkciju paypalDispatch()
-u funkciji paypalDispatch() kreiramo konfiguracioni objekt
-pozivamo funkciju paypalDispatch({ ... })
-dodajemo uslov if (order && !order.isPaid)
-u uslov if (order && !order.isPaid) dodajemo uslov if (!window.paypal)
-u uslov if (!window.paypal) dodajemo funkciju loadPayPalScript()

63. PayPal Buttons
-u komponentu OrderScreen.jsx dodajemo uslov {!order.isPaid && (...)}
-dodajemo uslov {loadingPay && <Loader />}
-dodajemo uslov {isPending ? <Loader /> : (...)}
-kreiramo komponentu Button Test Pay Order
-kreiramo funkciju onApproveTest()
-komponenti Button dodajemo prop onClick
-u prop onClick proslijedujemo funkciju onApproveTest
-kreiramo komponentu PayPalButtons
-komponenti PayPalButtons dodajemo props createOrder, onApprove, onError
-kreiramo 4 funkcije: onApprove(), onApproveTest(), onError(), createdOrder()
-u funkciju onApprove dodajemo return actions.order.capture().then
-dodajemo blokove koda try - catch

64. User Profile & Update
-u usersApiSlice.js fajlu kreiramo funkciju profile
-eksportujemo funkciju useProfileMutation
-u folderu screens kreiramo komponentu ProfileScreen.jsx
-u komponentu main.jsx importujemo komponentu ProfileScreen.jsx
-u zasticenoj ruti PrivateRoute kreiramo rutu '/profile' za komponentu ProductScreen.jsx
-ponovimo proces importovanja kao u ostalim komponentama
-u komponentu ProductScreen.jsx importujemo funkcije setCredentials i useProfileMutation 
-kreiramo state varijable name, email, password, confirmPassword
-kreiramo varijablu const dispatch
-destruktuiramo varijablu const { userInfo }
-kreiramo funkciju useEffect()
-u funkciji useEffect(), u callback funkciji kreiramo uslov if (userInfo)
-kreiramo funkciju submitHandler()
-u return izjavi kreiramo React Bootstrap komponente
-komponenti Form dodajemo prop onSubmit
-u prop onSubmit proslijedujemo funkciju submitHandler
-kreiramo funkciju useProfileMutation()
-destruktuiramo varijable const [updateProfile, { isLoading: loadingUpdateProfile }]
-dodajemo uslov {loadingUpdateProfile && <Loader />}
-u funkciju submitHandler() dodajemo uslov if (password !== confirmPassword) 
-dodajemo uslov else
-u uslov else dodajemo blokove koda try - catch
-u bloku koda try kreiramo varijablu const res 
-u blok koda catch dodajemo objekt toast.error()
-u blok koda try dodajemo funkciju dispatch(setCredentials(res))
-dodajemo objekt toast.success()

65. Display Order History
-u ordersApiSlice.js fajlu kreiramo funkciju getMyOrders
-eksportujemo funkciju useGetMyOrdersQuery
-u komponentu ProfileScreen.jsx importujemo funkciju useGetMyOrdersQuery
-kreiramo funkciju useGetMyOrdersQuery()
-destruktuiramo varijable const { data: orders, isLoading, error }
-u return izjavu dodajemo ternarni uslov {isLoading ? ... }
-u return izjavi, u komponenti Table kreiramo metodu orders?.map()


Section 11: Admin Functionality

66. Admin Route Component
-u folderu components kreiramo komponentu AdminRoute.jsx
-u komponenti AdminRoute.jsx destruktuiramo varijablu const { userInfo }
-u return izjavu dodajemo uslov userInfo && userInfo.isAdmin
-u folderu screens kreiramo komponentu OrderListScreen.jsx
-u komponentu main.jsx importujemo komponente AdminRoute.jsx i OrderListScreen.jsx
-u komponenti main.jsx kreiramo rutu za komponentu AdminRoute
-u zasticenoj ruti AdminRoute kreiramo rutu za komponentu OrderListScreen
-u folderu screens kreiramo folder admin
-u folder admin dodajemo komponentu dodajemo komponentu OrderListScreen.jsx
-u komponentu Header.jsx, u return izjavu dodajemo uslov {userInfo && userInfo.isAdmin} && ( ... )

67. List Orders For Admin
-ufolderu backend, u orderController.js fajlu, u funkciji getOrders() kreiramo varijablu const orders
-kreiramo metodu res.status(200).json(orders)
-u orderesApiSlice.js fajlu kreiramo funkciju getOrders()
-eksportujemo funkciju useGetOrdersQuery
-u komponentu OrderListScreen.jsx importujemo funkciju useGetOrdersQuery
-importujemo komponente Message.jsx i Loader.jsx
-importujemo komponentu FaTimes
-kreiramo funkciju useGetOrdersQuery()
-destruktuiramo varijable const { data:orders, isLoading, error }
-u return izjavu dodajemo uslov ternarni operator {isLoading ? ( ... )}
-kreiramo komponente React Bootstrap i HTML elemente za tabelu
-dodajemo uslov orders?.map((order) => ... )
-dodajemo uslov ternarni operator {order?.isPaid ? ( ... ) : ( ... )}
-dodajemo uslov ternarni operator {order?.isDelivered ? ( ... ) : ( ... )}

68. Deliver Order Status
-u orderController.js fajlu, u funkciji updateOrderToDelivered() kreiramo varijablu const order
-dodajemo uslov if (order)
-u uslovu if (order) kreiramo varijablu const updatedOrder
-dodajemo metodu res.status(200).json(updatedOrder)
-dodajemo uslov else
-u uslov else dodajemo metodu res.status(404) i objekt Error()
-u ordersApiSlice.js fajlu kreiramo funkciju deliverOrder()
-eksportujemo funkciju useDeliverOrderMutation
-u komponentu OrderScreen.jsx importujemo funkciju useDeliverOrderMutation
-kreiramo funkciju useDeliverOrderMutation()
-destruktuiramo varijable const [deliverOrder, { isLoading: loadingDeliver }]
-u return izjavi dodajemo uslov  {userInfo && userInfo.isAdmin && order.isPaid && !order.isDelivered && (...)}
-kreiramo funkciju deliverOrderHandler()
-u funkciju deliverOrderHandler() dodajemo blokove koda try - catch
-u blok koda try dodajemo funkciju deliverOrder(orderId)
-dodajemo funkciju refetch()
-dodajemo objekt toast.success('...')
-u blok koda catch dodajemo objekt toast.error(error)
-kreiramo komponentu Button
-komponenti Button dodajemo prop onClick
-u prop onClick proslijedujemo funkciju deliverOrderHandler

69. List Products For Admin
-u folderu admin kreiramo komponentu ProductListScreen.jsx
-u komponentu main.jsx importujemo komponentu ProductListScreen.jsx
-u zasticenoj ruti AdmirRoute kreiramo rutu za komponentu ProductListScreen
-u komponentu OrderListScreen.jsx importujemo funkciju useGetProductsQuery
-kreiramo funkciju useGetProductsQuery()
-destruktuiramo varijable const { data: products, isLoading, error }
-u return izjavi dodajemo uslov ternarni operator isLoading ? ( ... )
-u return izjavi kreiramo React Bootstrap komponente
-kreiramo funkciju deleteProductHandler()
-komponenti Button dodajemo prop onClick
-u prop onClick proslijedujemo funkciju deleteProductHandler

70. Creating Products
-u folderu backend, u productController.js fajlu kreiramo i eksportujemo funkciju createProduct()
-u funkciji createProduct() kreiramo varijablu const product
-kreiramo varijablu const createdProduct
-dodajemo metodu res.status(201).json(createdProduct)
-u productRoutes.js fajlu kreiramo rutu za funkciju createProduct
-importujemo funkcije protect, admin, createProduct
-u folderu frontend, u productsApiSlice.js fajlu kreiramo funkciju createProduct
-eksportujemo funkciju useCreateProductMutation
-u komponentu ProductListScreen.jsx importujemo funkciju useCreateProductMutation 
-kreiramo funkciju useCreateProductMutation()
-destruktuiramo varijable const [createProduct, { isLoading: loadingCreate }]
-kreiramo funkciju createProductHandler()
-komponenti Button Create Product dodajemo prop onClick
-u prop onClick proslijedujemo funkciju createProductHandler
-u funkciju createProductHandler() dodajemo uslov if (window.confirm(...))
-u uslov if dodajemo blokove koda try - catch
-u blok koda try dodajemo funkcije createProduct() i refetch()
-u blok koda catch dodajemo objekt toast.error()
-u return izjavi dodajemo uslov {loadingCreate && <Loader />}

71. Edit Product
-u folderu backend, u productController.js fajlu kreiramo i eksportujemo funkciju updateProduct()
-u funkciji updateProduct() destruktuiramo varijable iz req.body
-kreiramo varijablu const product
-dodajemo uslov if (product) 
-kreiramo varijablu const updatedProduct
-dodajemo metodu res.status(201).json(updatedProduct)
-dodajemo blok koda else
-u blok koda else dodajemo metodu res.status(404) i objekt Error()
-u productRoutes.js fajl importujemo funkciju updateProduct
-kreiramo rutu za funkciju updateProduct
-u productsApiSlice.js fajlu kreiramo funkciju updateProduct
-eksportujemo funkciju useUpdateProductMutation
-u folderu admin kreiramo komponentu ProductEditScreen.jsx
-u komponentu main.jsx importujemo komponentu ProductEditScreen.jsx
-u zasticenoj ruti AdminRoute kreiramo rutu za komponentu ProductEditScreen.jsx
-u komponentu ProductEditScreen.jsx importujemo funkcije useGetProductDetailsQuery, useUpdateProductMutation
-importujemo komponente iz paketa React Bootstrap
-importujemo komponente i funkcije iz paketa React Router Dom
-kreiramo funkciju useParams()
-importujemo React Hook useState i useEffect
-destruktuiramo varijablu const { id: productId }
-kreiramo vise state varijabli
-kreiramo funkciju useGetProductDetailsQuery(productId) 
-destruktuiramo varijable const { data: product, isLoading, refetch, error }
-kreiramo funkciju useUpdateProductMutation()
-destruktuiramo varijable const [updateProduct, { isLoading: loadingUpdating }]
-kreiramo varijablu const navigate
-kreiramo funkciju useEffect()
-u funkciji useEffect(), u callback funkciju dodajemo uslov if (product)
-u uslov if (product) dodajemo set funkcije
-u return izjavi kreiramo komponente React Bootstrap
-dodajemo uslov {loadingUpdating && <Loader />}
-dodajemo uslov ternarni operator {isLoading ? (...)}
-kreiramo komponente FormContainer, Form, Form.Group, Form.Label, Form.Control
-komponentama Form.Control dodajemo prop onChange
-kreiramo funkciju submitHandler()
-komponenti Form dodajemo prop onSubmit
-u prop onSubmit proslijedujemo funkciju submitHandler
-u funkciji submitHandler() kreiramo varijablu const updatedProduct 
-kreiramo varijablu const result 
-dodajemo uslov if (result?.error)
-u uslov if dodajemo objekt toast
-dodajemo uslov else
-u uslov else dodajemo objekt toast
-dodajemo funkciju navigate()
-u productsApiSlice.js fajl, u funkciju getProducts() dodajemo providesTags: ['Product']

72. Update Product Bug Fix

73. Multer & Image Upload Endpoint
-otvorimo link https://www.npmjs.com/package/multer
-u folderu backend instaliramo paket Multer sa komandom  npm i multer
-u folderu routes kreiramo uploadRoutes.js fajl
-u uploadRoutes.js fajl importujemo paket Multer
-kreiramo funkciju multer.diskStorage({ ... })
-vrijednost funkcije multer.diskStorage() pohranjujemo u varijablu const storage
-varijablu storage eksportujemo kao default
-kreiramo folder uploads
-u metodi diskStorage() kreiramo funkcije destination() i filename()
-kreiramo funkciju checkFileType() sa dva parametra file i cb
-kreiramo funkciju multer({ storage })
-vrijednost funkcije multer() pohranjujemo u varijablu const upload
-kreiramo metodu router.post('/', ...)
-u server.js fajl importujemo funkciju uploadRoutes
-kreiramo metodu app.use('/api/upload', uploadRoutes)
-importujemo modul path
-kreiramo varijablu const __dirname
-kreiramo metodu app.use('/uploads', ...)
-u folderu backend kreiramo folder uploads

74. Upload Product Image - Frontend
-u constants.js fajlu kreiramo varijablu const UPLOAD_URL
-u productsApiSlice.js fajlu kreiramo funkciju uploadProductImage
-eksportujemo funkciju useUploadProductImageMutation
-u komponentu ProductEditScreen.jsx importujemo funkciju useUploadProductImageMutation
-kreiramo funkciju useUploadProductImageMutation()
-destruktuiramo variant const [uploadProductImage, { isLoading: loadingUpload }]
-kreiramo komponente React Bootstrap za upload slike
-kreiramo funkciju uploadFileHandler()
-komponenti Form.Control dodajemo prop onChange
-u prop onChange proslijedujemo funkciju uploadFileHandler

75. Delete Product
-u productController.js fajlu kreiramo i eksportujemo funkciju deleteProduct()
-u productRoutes.js fajl importujemo funkciju deleteProduct
-kreiramo rutu za funkciju deleteProduct
-u productsApiSlice.js fajlu kreiramo funkciju deleteProduct
-eksportujemo funkciju useDeleteProductMutation
-u komponentu ProductListScreen.jsx importujemo funkciju useDeleteProductMutation
-kreiramo funkciju useDeleteProductMutation()
-destruktuiramo varijable const [deleteProduct, { isLoading: loadingDelete}]
-u funkciju deleteProductHandler() dodajemo uslov if (window.confirm('...'))
-u uslov if dodajemo blokove koda try - catch
-u blok koda try dodajemo await deleteProduct(id)
-dodajemo funkciju refetch()
-u blok koda catch dodajemo objekt Error()
-u return izjavu dodajemo uslov {loadingDelete && <Loader />}

76. Backend User Routes
-u userController.js fajlu, u funkciji getUsers() kreiramo varijablu const users
-u funkciji getUserById() kreiramo varijablu const user
-dodajemo uslov if (user) 
-u funkciji deleteUser() kreiramo varijablu const user
-dodajemo uslov if (user)
u uslov if (user) dodajemo uslvo if (user.isAdmin)
-dodajemo metodu  await User.deleteOne({ ... })
-dodajemo metodu res.status(200).json({ ... })
-dodajemo uslov else 
-u uslov else dodajemo metodu res.status(404) i objekt Error
-u funkciji updateUser() kreiramo varijablu const user
-dodajemo uslov if (user)
-u uslovu if (user) kreiramo varijablu const updatedUser
-dodajemo metodu res.status(200).json({ ... })
-dodajemo uslov else 
-u uslov else dodajemo metodu res.status(404) i objekt Error

77. List Users For Admin
-u usersApiSlice.js fajlu kreiramo funkciju getUsers
-eksportujemo funkciju useGetUsersQuery
-u folderu screens kreiramo komponentu UserListScreen.jsx
-u komponentu main.jsx importujemo komponentu UserListScreen.jsx
-u zasticenoj ruti AdminRoute, kreiramo rutu za komponentu UserListScreen.jsx
-sadrzaj iz komponente OrderListScreen.jsx kopiramo u komponentu UserListScreen i napravimo izmjene u varijablama
-kreiramo funkciju deleteUserHandler()
-u return izjavi kreiramo komponente React Bootstrap
-komponenti Button dodajemo prop onClick
-u prop onClick proslijedujemo funkciju deleteUserHandler

78. Delete User
-u usersApiSlice.js fajlu kreiramo funkciju deleteUser
-eksportujemo funkciju useDeleteUserMutation
-u komponentu UserListScreen.jsx importujemo funkciju useDeleteUserMutation
-kreiramo funkciju useDeleteUserMutation()
-destruktuiramo varijable const [deleteUser, { isLoading: loadingDelete }]
-u return izjavi dodajemo uslov {loadingDelete && <Loader />}
-u funkciju deleteUserHandler() dodajemo uslov if(window.confirm('...'))
-u uslov if dodajemo blokove koda try - catch
-u blok koda try dodajemo funkcije await deleteUser(id) i refetch()
-dodajemo objekt toast.success()
-u blok koda catch dodajemo objekt toast.error()

79. Update Users
-u usersApiSlice.js fajlu kreiramo funkcije getUserDetails i updateUser
-eksportujemo funkcije useGetUserDetailsQuery i useUpdateUserMutation
-u folderu screens kreiramo komponentu UserEditScreen.jsx
-u komande main.jsx importujemo komponentu UserEditScreen.jsx
-u zasticenoj rutu AdminRoute kreiramo rutu za komponentu UserEditScreen.jsx
-kopiramo sadrzaj iz komponente ProductEditScreen.jsx u komponentu UserEditScreen.jsx i izmjenimo imena varijabli
-u komponentu UserEditScreen.jsx importujemo funkcije  useUpdateUserMutation, useGetUserDetailsQuery
-kreiramo funkciju submitHandler()
-u funkciju submitHandler() dodajemo blokove koda try - catch
-u blok koda try dodajemo await updateUser({ ... })
-dodajemo objekt toast.success()
-dodajemo funkciju refetch()
-dodajemo funkciju navigate()
-u blok koda catch dodajemo objekt toast.error()


Section 12: Reviews, Search & More

80. Create Reviews - Backend
-u folderu backend, u productController.js fajlu kreiramo i eksportujemo funkciju createProductReview()
-u funkciji createProductReview() destruktuiramo varijable const { rating, comment }
-dodajemo uslov if (product)
-kreiramo varijablu const product
-dodajemo uslov if (product)
-u uslovu if (product) kreiramo varijablu const alreadyReviewed
-dodajemo uslov if (alreadyReviewed)
-kreiramo objekt varijablu const review 
-dodajemo metodu product.reviews.push(review)
-dodajemo metodu product.numReviews = product.reviews.length
-inicijaliziramo varijablu product.rating
-dodajemo metodu await product.save()
-dodajemo metodu res.status(201).json({ ... })
-u productRoutes.js fajl importujemo funkciju createProductReview
-kreiramo zasticenu rutu za funkciju createProductReview

81. Create Reviews - Frontend
-u productsApiSlice.js fajlu kreiramo funkciju createReview
-eksportujemo funkciju useCreateReviewMutation
-u komponentu ProductScreen.jsx importujemo funkciju useCreateReviewMutation 
-importujemo funkciju useSelector iz paketa React Redux
-importujemo objekt toast za paketa React Toastify
-kreiramo funkciju useCreateReviewMutation 
-destruktuiramo varijable const [createReview, { isLoading: loadingProductReview }]
-kreiramo state varijable rating i comment
-kreiramo funkciju useSelector()
-destruktuiramo varijablu const { userInfo }
-u return izjavi kreiramo komponentu Row sa klasom review
-dodajemo uslov {product.reviews.length === 0 && ...}
-u komponentu ListGroup dodajemo metodu product?.reviews?.map()
-dodajemo uslov {loadingProductReview && <Loader />}
-dodajemo uslov ternarni operator {userInfo ? ( ... ) : ( ... )}
-kreiramo asinhronu funkciju submitHandler()
-u funkciju submitHandler() dodajemo blokove koda try - catch
-u blok koda try dodajemo await createReview({ ... })
-dodajemo funkciju refetch()
-dodajemo objekt toast.success()
-dodajemo set funkcije setRating(0) i setComment('')
-komponenti Form dodajemo prop onSubmit
-u prop onSubmit proslijedujemo funkciju submitHandler
-u blok koda catch dodajemo objekt toast.error()

82. Paginate Products
-u productController.js fajlu, u funkciji getProducts() kreiramo varijable pageSize, page, count
-modelu Product dodajemo metode limit() i skip()
-u komponenti HomeScreen.jsx, umjesto products?.map() dodajemo data?.products?.map()
-importujemo i kreiramo funkciju useParams()
-destruktuiramo varijablu const { pageNumber }
-u komponenti main.jsx, u zasticenoj ruti PrivateRoute kreiramo novu rutu '/page/:pageNumber' za komponentu HomeScreen

83. Paginate Component
-u folderu comment kreiramo komponentu Paginate.jsx
-funkciji Paginate() dodajemo destruktuirane props pages, page, isAdmin = false
-u komponentu Paginate.jsx importujemo komponente Pagination i LinkContainer
-u komponentu HomeScreen.jsx importujemo komponentu Paginate.jsx
-u return izjavu dodajemo komponentu Paginate
-funkciji useGetProductsQuery() dodajemo argument { pageNumber }
-komponenti Paginate dodajemo props pages i page
-u komponenti ProductListScreen.jsx, umjesto metode products?.map() dodajemo data?.products?.map()
-importujemo i kreiramo funkciju useParams()
-destruktuiramo varijablu const { pageNumber }
-funkciji useGetProductsQuery() dodajemo argument { pageNumber }
-u komponenti main.jsx, u zasticenoj ruti AdminRoute kreiramo rutu '/admin/productlist/:pageNumber' za komponentu ProductListScreen
-u komponentu ProductListScreen.jsx importujemo komponentu Paginate.jsx
-u return izjavu dodajemo komponentu Paginate.jsx
-komponenti Paginate dodajemo props pages, page i isAdmin

84. Search Products
-u productController.js fajlu, u funkciji getProducts() kreiramo varijablu const keyword
-u komponenti HomeScreen.jsx destruktuiramo varijablu keyword
-u komponenti main.jsx kreiramo rute '/search/:keyword' i '/search/:keyword/page/:pageNumber' za komponentu HomeScreen
-u komponentu Paginate.jsx dodajemo ternarni uslov za varijablu keyword
-u komponenti HomeScreen.jsx, u return izjavi komponenti Paginate dodajemo props pages, page i keyword

85. Search Box Component
-u folderu components kreiramo komponentu SearchBox.jsx
-u komponentu SearchBox.jsx importujemo React Hook useState
-importujemo komponente Form i Button iz paketa React Bootstrap
-importujemo funkcije useParams i useNavigate iz paketa React Router Dom
-kreiramo varijablu const navigate
-destruktuiramo varijablu const { keyword: urlKeyword }
-kreiramo state varijablu keyword i set funkciju setKeyword
-kreiramo funkciju submitHandler()
-u funkciju submitHandler() dodajemo uslov if (keyword.trim())
-u return izjavi kreiramo komponente React Bootstrap
-komponenti Form dodajemo prop onSubmit
-u prop onSubmit proslijedujemo funkciju submitHandler
-komponenti Form.Control dodajemo prop onChange
-u prop onChange dodajemo funkciju setKeyword()
-u komponentu Header.jsx importujemo komponentu SearchBox.jsx
-u komponentu HomeScreen.jsx importujemo komponentu Link
-u return izjavu dodajemo uslov {keyword && <Link>...</Link>}

86. Product Carousel
-u productController.js fajlu kreiramo i eksportujemo funkciju getTopProducts()
-u funkciji getTopProducts() kreiramo varijablu const products
-dodajemo metodu res.status(200).json(products)
-u productRoutes.js importujemo funkciju getTopProducts
-u productRoutes.js fajlu kreiramo rutu za top products
-u productsApiSlice.js fajlu kreiramo funkciju getTopProducts
-eksportujemo funkciju useGetTopProductsQuery
-u folderu components kreiramo komponentu ProductCarousel.jsx
-u komponentu ProductCarousel.jsx importujemo komponente Carousel i Image iz pakete React Bootstrap
-importujemo funkciju useGetTopProductsQuery
-kreiramo funkciju useGetTopProductsQuery()
-destruktuiramo varijable const { data: products, isLoading, error } 
-u return izjavi kreiramo komponente React Bootstrap
-u komponenti Carousel.Item dodajemo metodu {products?.map()}
-u komponentu HomeScreen.jsx importujemo komponentu ProductCarousel
-u return izjavi dodajemo uslov ternarni operator {!keyword ? ... : ...}

87. Page Titles
-u folderu frontend instaliramo paket React Helmet Async 
-u terminal ukucamo komandu npm i react-helmet-async
-u komponentu main.jsx importujemo komponentu HelmetProvider iz paketa React Helmet Async
-u metodu render() dodajemo komponentu HelmetProviderž
-u folderu comment kreiramo komponentu Meta.jsx
-u komponentu HomeScreen.jsx importujemo komponentu Meta.jsx
-u komponentu ProductEditScreen.jsx, u return izjavi dodajemo uslov  {loadingUpload && <Loader />}


Section 13: Deploy to Production

88. Prepare For Production
-u folderu backend, u server.js fajlu dodajemo uslov if(NODE_ENV === 'production')
-kreiramo varijablu const NODE_ENV
-u .env fajlu kreiramo varijablu NODE_ENV
-dodajemo uslov else
-udemo u folderu frontend i u terminal ukucamo komandu npm run build
-nakon izvrsenja komande npm run build kreiramo se folder dist
-u productController.js fajlu kreiramo varijablu const PAGINATION_LIMIT
-u .env fajlu kreiramo varijablu PAGINATION_LIMIT

89. Deploy to Render
-otvorimo link https://dashboard.render.com/ za upload foldera backend

